# Week 11 - 질문 정리

#### 성아

1. [항목 49] new handler 함수를 사용자가 만들 때 지향해야 할 점은?

   > 1. 사용할 수 있는 메모리를 더 많이 확보한다
   >
   > 2. 다른 new 처리자를 설치한다
   >
   > 3. new 처리자의 설치를 제거한다
   >
   > 4. 예외를 던진다
   >
   > 5. 복귀하지 않는다
   
2. [항목 50] 개발자가 operator new와 delete를 바꿔야 하는 이유에 대해 설명해보시오

   > 1. 잘못된 힙 사용 탐지를 위해
   > 
   > 2. 효율 향상을 위해
   >
   > 3. 동적 할당 메모리의 실제 사용에 관한 통계 정보를 수집하기 위해
   
3. [항목 52] 위치지정 new 함수란 무엇인가?

   > 매개변수를 추가로 받는 형태로 선언한 operator new 함수


<br>

#### 재현


<br>

#### 현준

1. [항목 49] new 연산자가 실패하고 사용자정의 예외 처리 함수가 호출되었을 때, 예외 처리 함수 안에서 다시 동적 할당이 일어나고 실패한다고 해보자. 이 때 프로그램의 동작과 해결방안은?

   > 계속해서 사용자 정의 에러 처리 함수를 호출하고 실패하는 것을 반복한다
   >
   > 해결방안으로는 사용할 수 있는 메모리를 더 많이 확보하거나, 다른 new 처리자를 설치하거나, enw 처리자의 설치를 제거하거나, 예외를 던지게 하거나, 복귀하지 않는 해결 방안이 있다.


2. [항목 49] 클래스 템플릿 안에 static 멤버 변수 `static T value`가 있을 때, double 타입과 int 타입의 클래스 템플릿이 만들어졌다고 하자. 그 때 static 멤버 변수는 몇 개인가?

   > 2개. 템플릿 종류별로 static 멤버 변수의 사본이 만들어진다.
   >
   > [참고 링크](https://musket-ade.tistory.com/entry/C-%ED%95%A8%EC%88%98-%ED%85%9C%ED%94%8C%EB%A6%BF-%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%85%9C%ED%94%8C%EB%A6%BF%EA%B3%BC-static)


3. [항목 52] 위치지정 new를 사용하여 동적 할당을 한 후, 해제할 때 호출되는 delete 연산자는 위치지정 delete인가?

   > 아니요. 런타임 시스템이 기본형 delete 연산자를 호출한다


