# Week 7 - 상속, 그리고 객체 지향 설계

> Effective C++ / Chap6 / 항목32 - 항목35 (p.231-267)

### 목차

항목 32 : public 상속 모형은 반드시 "is-a(...는 ...의 일종이다)"를 따르도록 만들자

항목 33 : 상속된 이름을 숨기는 일은 피하자

항목 34 : 인터페이스 상속과 구현 상속의 차이를 제대로 파악하고 구별하자

항목 35 : 가상 함수 대신 쓸 것들도 생각해 두는 자세를 시시때때로 길러 두자

---

<br>

## INTRO

- 가상 함수 : 인터페이스가 상속되어야 한다
- 비가상 함수 : 인터페이스와 구현이 둘 다 상속 되어야 한다



## 항목 32 : public 상속 모형은 반드시 "is-a(...는 ...의 일종이다)"를 따르도록 만들자

> public 상속은 "is-a"를 의미한다
>

- **public 상속**은 기본 클래스 객체가 가진 **모든 것들**이 파생 클래스 객체에도 그대로 적용된다고 단정

<br>

## 항목 33 : 상속된 이름을 숨기는 일은 피하자

> 파생 클래스의 이름은 기본 클래스의 이름을 가린다.
>
> 가려진 이름을 다시 볼 수 있게 하는 방법으로 using 선언과 전달 함수 사용 방법이 있다.

- 컴파일러는 변수를 자신이 처리하고 있는 유효 범위(local scope)를 탐색하여 같은 이름을 가진 변수가 있는지 찾는다.

- 유효 범위 내에서 찾게 되면, 그 이상의 범위는 탐색하지 않는다

- 파생 클래스를 만들 때, 멀리 떨어진 기본 클래스로부터 오버로드 버전을 상속시키는 것은 지양해야 한다

- **using** : 기본 클래스로부터 상속을 받을 때, 오버로드된 함수가 그 클래스 안에 들어있고, 함수들 중 몇 개만 재정의(오버라이드)할 때 사용해야 함

  ```c++
  public:
  	using Base::mf1;
  	using Base::mf3;
  	...
  ```

- **전달함수 (forwarding function)** : using을 사용하면 그 이름에 해당되는 것들이 모두 파생클래스로 내려가버려, 그 중 일부만 사용하고 싶을 때 사용한다.

  ```c++
  class Base {
  public:
  	virtual void mf1() = 0;
  	virtual void mf1(int);
  	...
  };
  
  class Derived: private Base {
  public:
  	virtual void mf1() // 전달 함수
  	{ Base::mf1(); } // 암시적으로 인라인 함수가 된다
  }
  ```

<br>

## 항목 34 : 인터페이스 상속과 구현 상속의 차이를 제대로 파악하고 구별하자

> 인터페이스 상속은 구현 상속과 다르다
>
> **keyword** : 순수 가상 함수, 단순 가상 함수, 비가상 함수

- 함수 인터페이스의 상속 : public 상속에서, 파생 클래스는 항상 기본 클래스의 인터페이스를 모두 물려받는다. 

- 함수 구현의 상속

- 멤버 함수 인터페이스는 항상 상속되어 있다. 어떤 클래스에서 동작하는 함수는 반드시 파생 클래스에서도 동작해야 한다

- **순수 가상 함수**

  - 어떤 순수 가상 함수를 물려받은 구체 클래스는 해당 순수 가상 함수를 다시 선언해야 한다
  - 추상 클래스 안에서 정의를 갖지 않는다

  -> 순수 가상 함수를 선언하는 목적은 파생 클래스에게 함수의 **인터페이스**만을 물려주기 위함

- **단순(비순수) 가상 함수**

  - 파생 클래스로 하여금 함수의 인터페이스를 상속하게 함
  - 파생 클래스 쪽에서 오버라이드할 수 있는 함수 구현부도 제공

  -> 파생 클래스로 하여금 함수의 **인터페이스**뿐만 아니라 **그 함수의 기본 구현**도 물려받게 하기 위함

- **비가상 멤버 함수** 

  - 클래스 파생에 상관없이 변하지 않는 동작을 지정

  -> 즉, 파생 클래스가 함수 **인터페이스**와 더불어 그 함수의 **필수적인 구현**을 물려받게 함



## 항목 35 : 가상 함수 대신 쓸 것들도 생각해 두는 자세를 시시때때로 길러 두자

> 예외 안전성을 갖춘 함수는 예외가 발생하더라도 자원을 누출시키지 않고, 자료구조를 더럽히지 않는다

#### 비가상 인터페이스 관용구를 통한 템플릿 메소드 패턴

- 가상 은폐론 : 가상 함수는 반드시 private 멤버로 두어야 한다
- 비가상 함수 인터페이스 : public 멤버 함수를 통해 private 가상 함수를 간접적으로 호출하게 만드는 방법. Non-virtual interface(NVI) 관용구라고 함
  - 파생 클래스의 가상 함수 재정의를 허용한다
  - 어떤 **기능**을 어떻게 **구현**할지의 권한은 파생 클래스가 갖게 된다
  - 함수를 언제 **호출**할지는 기본 클래스만의 고유 권한이다

#### 함수 포인터로 구현한 전략 패턴

- 같은 타입으로 만들어진 객체(인스턴스)들도 특정 함수를 각각 다르게 가질 수 있다 (ex. 체력 계산 함수)
- 클래스 계통의 멤버 함수가 아니다 = 객체의 비공개 데이터는 이 함수로 접근할 수 없다
- 이를 해결하기 위해서는 비멤버 함수를 프렌드로 선언하는 등 캡슐화를 약하시키는 방법밖에 없다

#### trl::function으로 구현한 전략 패턴

- **trl::function** 계열의 객체 : 함수호출성 개체. 기존의 함수 포인터를 대신함.

<br>