# Week 8 - 질문 정리

#### 성아

1. [항목 36] 상속받은 비가상 함수를 재정의하면 안되는 이유를 설명해보시오

   > - 파생 클래스에서 상속받은 비가상 함수, 비가상 소멸자를 재정의하기 때문이다
   >
   > - 포인터 타입에 따라서 일관되지 못한 실행 결과를 보여주기 때문. 미정의 사항
   
2. [항목 38] 객체 합성의 두 가지 뜻을 설명해보시오

   > 1. "has-a" : 가지고 있다
   > 2. "is-implemented-in-terms-of" : A 객체는 B 객체를 사용하여 구현되는 형태의 설계
   
3. [항목 40] 다중상속을 하게 되면 발생하는 문제점을 설명해보시오

   > 둘 이상의 기본 클래스로부터 같은 이름을 물려받아 모호성이 생길 수 있다. 
   > 이럴때는, 컴파일러에서 최적 일치 함수를 찾은 후 함수 접근 가능성을 점검한다. 
   > 모호성을 해소하려면, 호출할 기본 클래스의 함수를 개발자가 손수 지정해줘야 한다.


<br>

#### 재현

1. [항목 36] 다음 코드에서 `p->eat();`은 어떤 객체의 `eat()`을 불러오는가?

   ```cpp
   person* p = new student(); 
   p->eat();
   ```

   > `person`의 비가상함수 `eat()`이 호출된다
   
2. [항목 38] 소프트웨어 개발에서 개발자가 대하는 영역 두 가지는?

   > 1. 응용 영역
   >
   > 2. 구현 영역

3. [항목 39] Public 상속에 객체 합성 조합이 더 자주 쓰이는 이유 두 가지는?

   > 파생은 가능하게 하되, 파생 클래스에서 재정의를 할 수 없도록 설계 차원에서 막고 싶을 때 유용하다. 컴파일 의존성을 최소화해준다



<br>

#### 현준

1. [항목36] override, final 키워드에 대해 설명해보시오

   > 둘 다 가상함수와 관련된 키워드
   >
   > override : 파생 클래스에서 기본 클래스의 가상 함수를 재정의할 때 사용하는 키워드. 실수로 함수의 시그니쳐를 잘못 쓰는 경우를 방지해준다
   >
   > final : 해당 키워드를 붙인 가상 함수는 더 이상 재정의(오버라이딩)하지 않겠다고 할 때 사용하는 키워드

2. [항목38] has-a 관계와 is-implemented-in-terms-of 관계에 대해 설명해보시오. 경험이나 예시도 좋습니다.

   > 1. has-a : 응용 영역에서 객체 합성의 의미. 사람 클래스는 이름, 나이, 주소를 가질 수는 있지만, 사람이 주소의 일종은 아니다
   >
   > 2. is-implemented-in-terms-of : 구현 영역에서 객체 합서읭 의미. set 자료 구조를 구현하기 위해 list를 사용하여 구현할 수 있다. 하지만, set은 list의 일종이 아니다

3. [항목40] 다중 상속의 문제점 중 특히 마름모 꼴이 되었을 때, 데이터가 중복 상속될 수 있다는 문제점이 있다. 이를 해결하기 위한 방법은 무엇인가?

   > 1. virtual 상속을 활용한다. 중복 상속되는 기본 클래스를 파생 클래스에서 virtual 상속하면 된다
   >
   > 2. [마름모 꼴과 가상 함수](https://hwan-shell.tistory.com/224)
   >
   > 3. 기본 클래스(중복 상속의 가능성이 있는 클래스)는 데이터 멤버를 가지지 않도록 설계한다