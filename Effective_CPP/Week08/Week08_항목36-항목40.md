# Week 8 - 상속, 그리고 객체 지향 설계

> Effective C++ / Chap6 / 항목36 - 항목40 (p.267-295)

### 목차

항목 36 : 상속받은 비가상 함수를 파생 클래스에서 재정의 하는 것은 절대 금물!

항목 37 : 어떤 함수에 대해서도 상속받은 기본 매개변수 값은 절대로 재정의하지 말자

항목 38 : "has-a(...는 ...를 가짐)" 혹은 "is-implemented-in-terms-of(...는 ...를 써서 구현됨)"를 모형화할 때는 객체 합성을 사용하자

항목 39 : private 상속은 심사숙고해서 구사하자

항목 40 : 다중 상속은 심사숙고해서 사용하자

---

<br>


## 항목 36 : 상속받은 비가상 함수를 파생 클래스에서 재정의 하는 것은 절대 금물!

> 상속받은 비가상 함수를 재정의하는 일은 절대 하지말아라

- 비가상 함수는 **정적 바인딩**으로 묶이게 된다
- 가상 함수는 **동적 바인딩**으로 묶인다
  > **용어 정리**
  >
  > 정적 바인딩 = 선행 바인딩
  >
  > 동적 바인딩 = 지연 바인딩
- 상속받은 비가상 함수를 재정의하는 것은 **절대 금물**
  - 파생 클래스에서 상속받은 비가상 함수, 비가상 소멸자를 재정의하기 때문이다
  - 컴파일러는 개발자가 직접 선언하지 않으면 자동으로 만들어주는 멤버 함수 중 하나가 **소멸자**

<br>

## 항목 37 : 어떤 함수에 대해서도 상속받은 기본 매개변수 값은 절대로 재정의하지 말자

> 상속받은 기본 매개변수 값은 절대로 재정의해서는 안된다
> 
> 기본 매개변수 값은 정적 바인딩되는 반면, 가상 함수는 동적으로 바인딩 되기 때문

- 가상 함수는 동적으로 바인딩되지만, 기본 매개변수 값은 정적으로 바인딩 된다
- 이는, 파생 클래스에 정의된 가상 함수를 호출하면서 기본 클래스에 정의된 기본 매개변수 값을 사용해버릴 수 있다
- 객체의 동적 타입은 현재 그 객체가 어떻게 동작할 것이냐를 가리키는 타입
- C++이 정적 바인딩을 사용하는 이유
  - 런타임 효율 때문
  - 동적 바인딩을 하게 되면 컴파일러에서 값을 결정할 방법을 마련해줘야 한다
  - 현재의 컴파일러 매커니즘보다 속도 유지와 구현 간편성을 고려하여 정적 바인딩을 사용한다

#### 비가상 함수가 매개변수를 지정하는 방법

-> **비가상 인터페이스(non-virtual interface, NVI)** 관용구를 사용하는 것

- 파생 클래스에서 재정의할 수 있는 가상 함수를 private 멤버로 둔다
- 가상 함수를 호출하는 public 비가상 함수를 기본 클래스에 만들어둔다
- 즉, 비가상 함수의 내부에서 진짜 일을 맡은 가상 함수를 호출하게 만든다

<br>

## 항목 38 : "has-a(...는 ...를 가짐)" 혹은 "is-implemented-in-terms-of(...는 ...를 써서 구현됨)"를 모형화할 때는 객체 합성을 사용하자

> 객체 합성의 의미는 public 상속이 가진 의미와 완전히 다르다
>
> 응용 영역에서 객체 합성의 의미는 has-a이다. 구현 영역에서는 is-implemented-in-terms-of의 의미를 갖는다

- **합성(composition)** : 어떤 타입의 객체들이 그와 다른 타입의 객체들을 포함하고 있는 경우에 성립하는 타입들간의 관계. **레이어링(layering)**, **포함(containment)**, **통합(aggregation)**, **내장(embedding)**이라고도 함
- 객체 합성은 "has-a"와 "is-implemented-in-terms-of", 두 가지의 뜻을 가지고 있다
- 개발에서 대하는 **영역(domain)**에 따라 어떤 뜻인지 달라진다
- **응용 영역(application domain)** : 일상 생활에서 볼 수 있는 사물들을 본뜬 객체들 -> "has-a"
- **구현 영역(implementation domain)** : 응용 영역에 속하지 않는 순수하게 시스템 구현만을 위한 인공물들 -> "is-implemented-in-terms-of"
  - 버퍼, 뮤텍스, 탐색 트리 등이 해당

- "has-a" : 가지고 있다
  - Person 객체는 이름, 주소, 전화번호를 **가지고 있다**
- "is-implemented-in-terms-of" : A 객체는 B 객체를 사용하여 구현되는 형태의 설계
  - STL의 Set 객체를 List 객체를 사용하여 설계함
  - 두 객채간의 관계가 중요한 요소


<br>

## 항목 39 : private 상속은 심사숙고해서 구사하자

> private 상속의 의미는 is-implemented-in-terms-of 이다.
>
> 파생 클래스 쪽에서 기본 클래스의 protected 멤버에 접근해야 할 경우나, 상속 받은 가상 함수를 재정의해야 하는 경우 private 상속을 사용한다
>
> 객체 합성과 달리 private 상속은 공백 기본 클래스 최적화(EBO)를 활성화시킬 수 있다

- private 상속 : 구현만 물려받을 수 있다. 인터페이스는 국물도 없다
  - 파생 클래스 객체를 기본 클래스로 변환하지 않는다
  - 기본 클래스로부터 물려받은 멤버는 파생 클래스에서 모두 private 멤버가 된다
  - 소프트웨어 설계 도중에는 아무런 의미를 갖지 않는다
  - 오직 소프트웨어 구현(implementation) 중에만 의미를 가진다

#### private 상속 vs 객체 합성

- 1순위는 **객체 합성**
- 꼭 private 상속이 필요한 경우에만 private 상속을 할 것
- 언제 Private? : **비공개 멤버를 접근하거나 가상 함수를 재정의 할 때**, **공간 최적화 문제가 있을 때**
  - 공백 클래스(empty class) : 데이터가 전혀 없는, 비정적 데이터 멤버가 없는 경우. 가상함수도 없고, 가상 기본 클래스도 없어야 한다
  - 공백 클래스는 개념적으로 차지하는 메모리 공간이 없어야 함
  - 하지만, C++에서 **독립 구조의 객체는 반드시 크기가 0이상이어야 한다**는 금지사항이 있음
  - 이럴땐 Empty 타입의 객체를 데이터 멤버로 두지말고, private 상속을 시키면 객체의 크기가 0이 된다
  - 이를 **공백 기본 클래스 최적화(empty base optimization: EBO)**라 함
  - 주의 : EBO는 **단일 상속**에서만 적용됨. 기본 클래스를 두 개 이상 갖는 파생 클래스는 적용 X
- private 상속 보다는 public 상속 + 객체 조합이 더 선호된다

<br>

## 항목 40 : 다중 상속은 심사숙고해서 사용하자

> 다중상속은 단일 상속보다 복잡하다. 모호성이 있으며, 비용이 많이드는 가상 상속이 필요할 수도 있다
>
> 가상 상속을 사용하면, 크기 비용, 속도 비용이 늘어난다. 초기화 및 대입연산의 복잡도가 커진다. 따라서, 가상기본클래스에는 데이터를 두지 않는 것이 좋다 
>
> 다중상속을 적법하게 사용하는 경우는 인터페이스 클래스로부터 Public 상속시킴과 동시에 구현을 돕는 클래스로부터 private 상속을 시키는 것

#### C++에서의 다중 상속 관련 견해

- 단일 상속(single inheritance, SI)이 좋다면 다중 상속은 더 좋다
- 단일 상속은 좋지만 다중 상속은 골칫거리다

> 참고 : JAVA는 다중상속을 막고 있는다

#### 다중 상속을 하게 된다면?

- 둘 이상의 기본 클래스로부터 같은 이름을 물려받아 모호성이 생길 수 있다
- 이럴때는, 컴파일러에서 최적 일치 함수를 찾은 후 함수 접근 가능성을 점검한다
- 모호성을 해소하려면, 호출할 기본 클래스의 함수를 개발자가 손수 지정해줘야 한다

#### 죽음의 마름모꼴과 가상상속

다중상속(Multiple Inheritance) 중 "죽음의 MI 마름모꼴"이라고 알려진 좋지 않은 모양이 있다

![Image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FctYaUw%2FbtqCNaR2oeE%2FyBHyIpSvHYjtuczAVuKkc0%2Fimg.png)

-> 마름모꼴로 다중상속시 inputFile과 Outputfile의 데이터멤버가 IOFile에서 중복될 것이다

- 해결방법 : 한 개의 기본 클래스(File)을 2개의 클래스(InputFile, OutputFile)가 **가상상속**한다면, File의 객체가 1개만 생성되므로 중복을 방지할 수 있다
- 문제점 : 가상상속시 발생하는 초기화, 가상테이블등과 같은 문제로 비용이 비싸다
- 결론 : 가상상속은 지양하는 것이 좋고, 써야하는 상황이라면 가상클래스에는 데이터를 넣지 마라
