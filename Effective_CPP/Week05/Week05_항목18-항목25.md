# Week 5 - 설계 및 선언

> Effective C++ / Chap4 / 항목18 - 항목25 (p.139-182)

### 목차

항목 18 : 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자

항목 19 : 클래스 설계는 타입 설계와 똑같이 취급하자

항목 20 : '값에 의한 전달'보다는 '상수객체 참조자에 의한 전달' 방식을 택하는 편이 대개 낫다

항목 21 : 함수에서 객체를 반환해야 할 경우에 참조자를 반환하려고 들지 말자

항목 22 : 데이터 멤버가 선언될 곳은 private 영역임을 명심하자

항목 23 : 멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워지자

항목 24 : 타입 변환이 모든 매개변수에 대해 적용되어야 한다면 비멤버 함수를 선언하자

항목 25 : 예외를 던지지 않는 swap에 대한 지원도 생각해 보자

---

<br>

## 항목 18 : 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자

> 일관성 있는 인터페이스를 제공할 수 있도록 하는 방법
>

#### 인터페이스를 강화하는 방법

- 새로운 타입 생성 -> 매개 변수 순서가 잘 못 들어오는 일을 막을 수 있음

  ```c++
  struct Day {
  	explicit Day(int d) : val(d) {}
  	int val;
  };
  // Month와 Year도 같은 형식으로 만들어 줌
  
  Date d(Month(3), Day(30), Year(1995));
  //매개변수 순서가 바뀌어도 정상적인 동작이 가능
  ```

- 타입에 대한 연산 제한, 객체 값에 대해 제약

- 객체를 동적 할당하는 함수는 팩토리 함수가 스마트 포인터를 반환하도록 만들어 자원 누출을 피하라 -> 교차 DLL 문제 방지

  - shared_ptr은 사용자 정의 삭제자를 지원한다

  > **교차 DLL 문제** : 동적 링크 라이브러리의 new를 썼는데 그 객체를 삭제할 때 다른 DLL에 있는 delete를 사용한 경우

- 실제 객체 포인터는 생성자에 넘겨버리는 것이 더 낫다

<br>

## 항목 19 : 클래스 설계는 타입 설계와 똑같이 취급하자

> 효과적인 클래스를 정의하기 위한 방법

- 새로 정의한 타입의 객체 생성 및 소멸은 어떻게 이루어져야 하는가?
  - 클래스 생성자 / 소멸자의 설계 관여
  - 메모리 할당 함수를 직접 작성할 경우 관여
- 객체 초기화는 객체 대입과 어떻게 달라야 하나?
  - 생성자와 대입 연산자의 동작과 차이점을 결정
- 새로운 타입으로 만든 객체가 값에 의해 전달되는 경우에 어떤 의미를 줄 것인가?
  - 값에 의한 전달은 복사 생성자에서 구현됨
- 새로운 타입이 가질 수 있는 적법한 값에 대한 제약은 무엇으로 잡을 것인가?
  - **클래스의 불변속성** : 클래스의 데이터 멤버의 몇 가지 조합 값만은 반드시 유효해야 함
  - 생성자, 대입 연산자, 쓰기(setter) 함수는 불변속성 영향을 많이 받음
- 기존의 클래스 상속 계통망(inheritance graph)에 맞출 것인가?
  - 멤버가 가상 / 비가상 인지
  - 소멸자가 영향을 많이 받음
- 어떤 종류의 타입 변환을 허용할 것인가?
  - 암시적 / 명시적 타입 변환
- 어떤 연산자와 함수를 두어야 의미가 있을까?
  - 클래스 안에 선언할 함수
- 표준 함수들 중 어떤 것을 허용하지 말 것인가?
  - private로 선언해야 하는 함수
- 새로운 타입의 멤버에 대한 접근권한을 어느 쪽에 줄 것인가?
  - public, protected, private 영역 관련
  - 프렌드로 만들어야 하는 클래스 및 함수
- '선언되지 않은 인터페이스'로 무엇을 둘 것인가?
  - 타입이 제공할 보장의 종류
  - 수행 성능, 예외 안전성, 자원 사용
- 새로 만드는 타입이 얼마나 일반적인가?
  - 동일 계열의 타입군인지 체크
- 정말로 꼭 필요한 타입인가?
  - 기존 클래스의 기능이 다소 아쉽다면 비멤버 함수나 템플릿을 몇 개 더 정의하는 것이 낫다

<br>

## 항목 20 : '값에 의한 전달'보다는 '상수객체 참조자에 의한 전달' 방식을 택하는 편이 대개 낫다

> **값에 의한 전달**보다는, **상수 객체 참조자에 의한 전달**을 선호할 것

- C++에서 함수로부터 객체를 전달받거나 할 때, 값에 의한 전달 방식을 사용 -> 실제 인자의 사본 사용
- 값에 의한 전달은 복사 생성자가 만들어내고, 고비용의 연산이 듦
- 해결방법 : **상수객체에 대한 참조자(reference-to-const)로 전달**
  - 복사손실 문제(slicing problem) 방지
- 단, 기본제공 타입, STL 반복자, 함수 객체 타입에는 '값에 의한 전달'이 더 적절

<br>

## 항목 21 : 함수에서 객체를 반환해야 할 경우에 참조자를 반환하려고 들지 말자

> 참조자를 반환할 것인가? 객체를 반환할 것인가?에 대한 결정

#### 다음과 같은 객체가 두 가지 이상 생길 일이 있으면 하지 말아야 함

- 지역 스택 객체에 대한 포인터나 참조자를 반환하는 일
- 힙에 할당된 객체에 대한 참조자를 반환하는 일
- 지역 정적 객체에 대한 포인터나 참조자를 반환하는 일

<br>

## 항목 22 : 데이터 멤버가 선언될 곳은 private 영역임을 명심하자

> 데이터 멤버를 private 멤버로 선언해야 하는 이유

- 구현상의 융통성을 위해 private 영역을 사용
  - 문법적으로 일관성 있는 데이터 접근 통로를 제공
  - 캡슐화 되었음을 의미
  - 클래스의 불변속성 및 사전조건, 사후조건 검증
  - 스레딩 환경 동기화
- protected는 public보다 더 많이 보호 받고 있는 것이 절대 아니다

<br>

## 항목 23 : 멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워지자

> 비멤버 비프렌드 함수를 사용해야 되는 이유

캡슐화 : 외부에서 볼 수 없다 -> 바꿀 때 필요한 유연성 증가

프렌드(friend) : 해당 객체 멤버 함수가 아닌 함수가 private 멤버에 접근할 수 있도록 해줌

비멤버 비프렌드 함수의 이점

- 캡슐화 정도가 높아짐
- 패키징 유연성 커짐
- 기능적인 확장성 늘어남

<br>

## 항목 24 : 타입 변환이 모든 매개변수에 대해 적용되어야 한다면 비멤버 함수를 선언하자

> 함수에 들어가는 모든 매개변수에 대해 타입 변환을 해 줄 필요가 있다면, 그 함수는 비멤버이어야 함

암시적 타입 변환에 대해 매개변수가 먹혀들려면 **매개변수 리스트에 들어 있어야만 한다**

<br>

## 항목 25 : 예외를 던지지 않는 swap에 대한 지원도 생각해 보자

> std::swap이 효율을 보이지 못할 때 사용하는 방법

- 표준에서 제공하는 swap이 내가 사용할 클래스, 클래스 템플릿에 괜찮은 효율을 보이면 아무 것도 하지 말 것
- swap 효율이 충분하지 않을 때 하는 방법
  1. 내가 만든 타입의 객체를 바꾸는 swap 함수를 만들고, public 멤버 함수로 둘 것. 반드시 예외를 던져선 안됨
  2. 클래스 혹은 템플릿이 들어 있는 네임스페이스와 같은 네임스페이스에 비멤버 swap을 만듦. 1번에서 만든 swap 멤버 함수를 이 비멤버 함수가 호출하도록 함
  3. 새로운 클래스를 만들고 있다면, 클래스에 대한 std::swap의 특수화 버전 준비. 그 버전에서도 swap 멤버 함수를 호출하도록 함
- 사용자 입장에서 swap 호출 시, std::swap을 볼 수 있도록 using 선언을 반드시 포함하기
- std에 어떤 것이라도 새로 추가하려고 하면 안됨