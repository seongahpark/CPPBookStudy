# Week 5 - 질문 정리

#### 성아

1. 일관성 있는 인터페이스를 만들기 위한 방법들을 설명해보시오

   > - 새로운 타입 생성
   >- 타입에 대한 연산 제한, 객체 값에 대한 제약
   > - 스마트 포인터 반환
   
2. 값에 의한 전달이 지양되는 이유를 설명해보시오

   > 값에 의한 전달은 복사 생성자가 사본을 만드는 방식으로 고비용의 연산이 든다
   > 
   > 또한, 복사손실 문제를 방지하기 위해 지양한다
   
3. 프렌드 함수란 무엇인가? 그리고 비멤버 비프렌드 함수의 이점은 무엇인가?

   > **프렌드(friend)** : 해당 객체 멤버 함수가 아닌 함수가 private 멤버에 접근할 수 있도록 해줌
   >
   > 비멤버 비프렌드 함수의 이점은 캡슐화 정도가 높아지고, 패키징 유연성이 커지며, 기능적인 확장성이 늘어난다

<br>

#### 현준

1. 상수객체 참조자 전달(reference to const)의 이점은 무엇인가?

   > 생성자와 소멸자가 호출되지 않는다
   >
   > Const 키워드로 인해 원본이 수정되지 않는다는 보장을 얻는다
   >
   > 복사손실 문제가 발생하지 않는다

2. 값에 의한 전달을 해야 할 경우는 언제인가?

   > 기본제공 타입, STL 반복자, 함수 객체 타입을 사용해야 할 때
   >
   > 이외에는 상수객체 참조자에 의한 전달을 사용하는 편이 이득이다

3. 함수에서 참조자 반환시 발생하는 문제점

   > 함수 내부에 객체를 생성하여 그 객체의 참조자를 반환하면 해제된 메모리에 접근하게 됨
   >
   > 함수 내부에 동적으로 메모리를 할당한 후에 반환할 때 적절한 메모리 해제를 하지 못하게 될 수 있다 -> 자원 누수의 가능성

4. 데이터 멤버가 private이어야 하는 이유

   > 문법적 일관성 : 클래스 멤버에 접근하고 싶을 때, 사용자는 함수만 사용하면 된다
   >
   > 정교한 제어 : 함수로 제어하게 되면, '접근불가/읽기전용/읽기 쓰기 가능' 등의 기능을 특정하게 만들 수 있다
   >
   > 캡슐화 : 외부에 노출시키지 않을 수 있다

<br>

#### 재현

1. Pimple을 사용하는 이유에 대해 설명해보시오

   > 컴파일 시간이 단축됨 (swap시 포인터만 서로 교체하면 되기 때문)
   >
   > 인터페이스와 구현과 분리

2. 값에 의한 전달을 사용하는 케이스에 대해 설명해보시오

   > 현준 2번 답

3. 정말로 꼭 필요한 타입이 아닐 때는 어떻게 해야하는가

   > 파생클래스로 만들기 보다는 비멤버 함수 또는 템플릿 정의 방식을 사용한다
