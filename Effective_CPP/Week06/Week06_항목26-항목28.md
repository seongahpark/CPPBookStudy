# Week 6 - 구현

> Effective C++ / Chap5 / 항목26 - 항목28 (p.183-200)

### 목차

항목 26 : 변수 정의는 늦출 수 있는 데까지 늦추는 근성을 발휘하자

항목 27 : 캐스팅은 절약, 또 절약! 잊지 말자

항목 28 : 내부에서 사용하는 객체에 대한 '핸들'을 반환하는 코드는 되도록 피하자

---

<br>

## 항목 26 : 변수 정의는 늦출 수 있는 데까지 늦추는 근성을 발휘하자

> 일관성 있는 인터페이스를 제공할 수 있도록 하는 방법
>

#### 인터페이스를 강화하는 방법

- 새로운 타입 생성 -> 매개 변수 순서가 잘 못 들어오는 일을 막을 수 있음

  ```c++
  struct Day {
  	explicit Day(int d) : val(d) {}
  	int val;
  };
  // Month와 Year도 같은 형식으로 만들어 줌
  
  Date d(Month(3), Day(30), Year(1995));
  //매개변수 순서가 바뀌어도 정상적인 동작이 가능
  ```

- 타입에 대한 연산 제한, 객체 값에 대해 제약

- 객체를 동적 할당하는 함수는 팩토리 함수가 스마트 포인터를 반환하도록 만들어 자원 누출을 피하라 -> 교차 DLL 문제 방지

  - shared_ptr은 사용자 정의 삭제자를 지원한다

  > **교차 DLL 문제** : 동적 링크 라이브러리의 new를 썼는데 그 객체를 삭제할 때 다른 DLL에 있는 delete를 사용한 경우

- 실제 객체 포인터는 생성자에 넘겨버리는 것이 더 낫다

<br>

## 항목 27 : 캐스팅은 절약, 또 절약! 잊지 말자

> 효과적인 클래스를 정의하기 위한 방법

- 새로 정의한 타입의 객체 생성 및 소멸은 어떻게 이루어져야 하는가?
  - 클래스 생성자 / 소멸자의 설계 관여
  - 메모리 할당 함수를 직접 작성할 경우 관여
- 객체 초기화는 객체 대입과 어떻게 달라야 하나?
  - 생성자와 대입 연산자의 동작과 차이점을 결정
- 새로운 타입으로 만든 객체가 값에 의해 전달되는 경우에 어떤 의미를 줄 것인가?
  - 값에 의한 전달은 복사 생성자에서 구현됨
- 새로운 타입이 가질 수 있는 적법한 값에 대한 제약은 무엇으로 잡을 것인가?
  - **클래스의 불변속성** : 클래스의 데이터 멤버의 몇 가지 조합 값만은 반드시 유효해야 함
  - 생성자, 대입 연산자, 쓰기(setter) 함수는 불변속성 영향을 많이 받음
- 기존의 클래스 상속 계통망(inheritance graph)에 맞출 것인가?
  - 멤버가 가상 / 비가상 인지
  - 소멸자가 영향을 많이 받음
- 어떤 종류의 타입 변환을 허용할 것인가?
  - 암시적 / 명시적 타입 변환
- 어떤 연산자와 함수를 두어야 의미가 있을까?
  - 클래스 안에 선언할 함수
- 표준 함수들 중 어떤 것을 허용하지 말 것인가?
  - private로 선언해야 하는 함수
- 새로운 타입의 멤버에 대한 접근권한을 어느 쪽에 줄 것인가?
  - public, protected, private 영역 관련
  - 프렌드로 만들어야 하는 클래스 및 함수
- '선언되지 않은 인터페이스'로 무엇을 둘 것인가?
  - 타입이 제공할 보장의 종류
  - 수행 성능, 예외 안전성, 자원 사용
- 새로 만드는 타입이 얼마나 일반적인가?
  - 동일 계열의 타입군인지 체크
- 정말로 꼭 필요한 타입인가?
  - 기존 클래스의 기능이 다소 아쉽다면 비멤버 함수나 템플릿을 몇 개 더 정의하는 것이 낫다

<br>

## 항목 28 : 내부에서 사용하는 객체에 대한 '핸들'을 반환하는 코드는 되도록 피하자

> **값에 의한 전달**보다는, **상수 객체 참조자에 의한 전달**을 선호할 것

- C++에서 함수로부터 객체를 전달받거나 할 때, 값에 의한 전달 방식을 사용 -> 실제 인자의 사본 사용
- 값에 의한 전달은 복사 생성자가 만들어내고, 고비용의 연산이 듦
- 해결방법 : **상수객체에 대한 참조자(reference-to-const)로 전달**
  - 복사손실 문제(slicing problem) 방지
- 단, 기본제공 타입, STL 반복자, 함수 객체 타입에는 '값에 의한 전달'이 더 적절
