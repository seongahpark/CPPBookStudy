# Week 6 - 구현

> Effective C++ / Chap5 / 항목26 - 항목28 (p.183-200)

### 목차

항목 26 : 변수 정의는 늦출 수 있는 데까지 늦추는 근성을 발휘하자

항목 27 : 캐스팅은 절약, 또 절약! 잊지 말자

항목 28 : 내부에서 사용하는 객체에 대한 '핸들'을 반환하는 코드는 되도록 피하자

항목 29 : 예외 안전성이 확보되는 그날 위해 싸우고 또 싸우자!

항목 30 : 인라인 함수는 미주알고주알 따져서 이해해 두자

항목 31 : 파일 사이의 컴파일 의존성을 최대로 줄이자

---

<br>

## 항목 26 : 변수 정의는 늦출 수 있는 데까지 늦추는 근성을 발휘하자

> 변수 정의는 늦출 수 있을 때까지 늦추는게 프로그램이 더 깔끔해지고 효율이 좋다
>

- 생성자/소멸자를 끌고 다니는 타입으로 변수를 정의하면 물게되는 비용
  - 프로그램 제어 흐름이 변수 정의에 닿을 때 생성자가 호출되는 비용
  - 변수가 유효범위를 벗어날 때 소멸자가 호출되는 비용

-> 이렇게 되면, 쓰지도 않을 객체가 만들어졌다가 없어지는 일이 생길 수 있다.

- 생성자/소멸자 호출 비용 vs 대입 비용으로 객체 위치 정하기

  > 1. 대입이 생성자-소멸자 쌍보다 비용이 덜 든다
  > 2. 전체 코드에서 수행 성능에 민감한 부분을 건드린다
  >
  > -> 이러면 무조건 생성자, 소멸자를 최소한으로 호출할 수 있는 곳에서 위치 정의

<br>

## 항목 27 : 캐스팅은 절약, 또 절약! 잊지 말자

> 다른 방법이 있다면 캐스팅은 피하라
>
> 불가피하게 써야하는 경우라면 함수 안에 숨기도록 하라
>
> 구형 스타일보다는 C++ 스타일 캐스트를 사용하라

- C++의 동작 규칙 : 어떤 일이 있어도 타입 에러가 생기지 않도록 보장한다

- 구형 스타일 캐스트 문법

  - C 스타일 캐스트

    ```C++
    (T) 표현식 // 표현식 부분을 T 타입으로 캐스팅한다
    ```

  - 함수 방식 캐스트

    ```C++
    T(표현식) // 표현식 부분을 T타입으로 캐스팅 한다
    ```

- C++ 스타일 캐스트 (신형 스타일)

  - **const_cast** : 객체의 상수성을 없애는 용도로 사용된다.
  - **dynamic_cast** : 안전한 다운캐스팅을 할 때 사용하는 연산자. 주어진 객체가 어떤 클래스 상속 계통에 속한 특정 타입인지 아닌지를 결정하는 작업에 쓰인다. 런타임 비용이 높은 캐스트
  - **reinterpret_cast** : 하부 수준 캐스팅을 위해 만들어진 연산자, 구현환경에 의존적이어서 이식성이 없다. (포인터를 int로 바꿈)
  - **static_cast** : 암시적 변환을 강제로 진행할 때 사용. 타입 변환을 거꾸로 수행하는 용도로 쓰인다.

- 타입 변환이 생기면 런타임에 실행되는 코드가 만들어지는 경우가 꽤 있다

- 캐스팅을 해야 하는 코드는 내부 함수 속에 몰아 놓고, 그 안에서 일어나는 일들을 외부에서 알 수 없도록 인터페이스로 막아둬야 함

<br>

## 항목 28 : 내부에서 사용하는 객체에 대한 '핸들'을 반환하는 코드는 되도록 피하자

> 어떤 객체의 내부요소에 대한 핸들을 반환하는 것은 지양하라

- **핸들(handle)** : 다른 객체에 손을 댈 수 있게 하는 매개자

  - 참조자, 포인터, 반복자

- 클래스 데이터 멤버는 아무리 숨겨봤자 그 멤버의 참조자를 반환하는 함수들의 최대 접근도에 따라 캡슐화 정도가 정해진다

  -> 반환 타입에 const 키워드를 붙여주면 읽기만 가능해진다

- 무효참조 핸들 : 핸들이 있기는 하지만 핸들을 따라갔을 때 실제 객체의 데이터가 없는 것. 따라서 핸들을 반환하는 것은 피해야 함

- 핸들을 반환하지 않는데서 얻는 이점

  - 캡슐화 정도를 높임
  - 상수 멤버 함수가 객체의 상수성을 유지한 채로 동작 가능
  - 무효참조 핸들이 생기는 경우를 최소화

<br>

## 항목 29 : 예외 안전성이 확보되는 그날 위해 싸우고 또 싸우자!

> 예외 안전성을 갖춘 함수는 예외가 발생하더라도 자원을 누출시키지 않고, 자료구조를 더럽히지 않는다

#### 예외 안전성을 가지는 함수를 만드는 방법

- 자원이 새도록 만들지 않는다 : 객체를 사용하여 자원 관리를 전담케 하고, 적절한 시점에 해제하는 방법을 사용
- 자료구조가 더렵혀지는 것을 허용하지 않는다
- 복사 후 맞바꾸기 전략 사용 : 어떤 객체를 수정할 때 객체의 사본을 하나 만들어 놓고 사본을 수정한 후 원본 객체와 맞바꾼다. (pimpl 관용구)
  - 장점 : 강력한 예외 안전성 보장 제공
  - 단점 : 수정하고 싶은 객체를 복사해 둘 공간과 복사에 걸리는 시간을 감수해야 함 -> 기본적인 보장을 선택하는 방향으로 해결

#### 예외 안전성을 갖춘 함수의 세 가지 보장

- 기본적인 보장 : 함수 동작 중 예외가 발생하면, 실행 중인 프로그램에 관련된 모든 것들을 유효한 상태로 유지
- 강력한 보장 : 함수 동작 중 예외가 발생하면, 프로그램의 상태를 절대로 변경하지 않겠다는 보장. 원자적인 동작이다.
- 예외불가 보장 : 예외를 절대로 던지지 않겠다는 보장. 약속한 동작은 언제나 끝까지 완수하는 함수.

<br>

## 항목 30 : 인라인 함수는 미주알고주알 따져서 이해해 두자

> 함수 인라인은 작고, 자주 호출되는 함수에 대해서만 사용
>
> 함수 템플릿을 함부로 inline 선언하면 안된다

- inline 함수 : 함수 호출 위치에 호출된 함수를 끼워 넣는 작업을 프로그램 실행 전에 한다
- virtual 함수 : 어떤 함수를 호출할지 결정하는 작업을 실행 중에 한다
- 인라인 함수 선언하는 명시적인 방법 : 함수 정의 앞에 inline 키워드를 붙임
- inline은 컴파일러 선에서 무시할 수 있는 요청
- inline 장점
  - 함수처럼 보이며 함수처럼 동작한다
  - 매크로보다 안전하고 쓰기 좋다
  - 함수 호출 시 발생하는 오버헤드를 걱정할 필요가 없다
  - 함수 호출 비용이 면제된다 : 컴파일러가 함수 본문에 대해 문맥별 최적화를 걸기 용이하다. 아웃라인 함수 호출에 대해서는 최적화를 적용하지 않기 때문.
- inline 단점
  - 디버깅이 어렵고 및 라이브러리 바이너리 업그레이드가 느리다
  - 코드 부풀림 현상
  - 프로그램이 느려질 수 있음

<br>

## 항목 31 : 파일 사이의 컴파일 의존성을 최대로 줄이자

> 컴파일 의존성을 최소화 하는 작업 -> 정의 대신에 선언에 의존하자
>
> 라이브러리 헤더는 그 자체로 모든 것을 갖추고, 선언부만 갖고 있는 형태여야 한다

헤더 파일이 바뀌면 엮여있는 다른 파일까지 영향이 간다 -> **컴파일 의존성**이 생김

#### 컴파일 의존성을 최소화 하는 방법

- 객체 참조자 및 포인터로 충분한 경우에 객체를 직접 쓰지 않는다 : 어떤 타입에 대한 참조자 및 포인터를 정의할 때는 그 타입의 선언부만 필요. 반면, 어떤 타입의 객체를 정의할 때는 그 타입의 정의가 준비되어 있어야 함
- 가능하다면 클래스 정의 대신 클래스 선언에 최대한 의존하도록 만들어라 : 선언이 되어 있는 헤더 파일 쪽에 부담을 주지 않고 실제 함수 호출이 일어나는 사용자의 소스 파일 쪽에 전가하는 방법을 사용할 것
- 선언부와 정의부에 대해 별도의 헤더 파일을 제공 : export 키워드를 사용할 수 있는 환경이면 사용, 하지만 대부분은 그런 환경이 아니기 때문에 핸들 클래스나 인터페이스 클래스를 사용해 볼 것

- 핸들 클래스 : pimpl 관용구를 사용한느 클래스. 핸들 클래스에 대응되는 구현 클래스 쪽으로 함수 호출을 전달하여 구현 클래스가 실제 작업을 수행하도록 함
  - 핸들 클래스에 접근할 때마다 요구되는 간접화 연산이 증가한다 (포인터를 타야하기 때문)
  - 객체 하나씩을 저장하는데 필요한 메모리 크기에 구현부 포인터의 크기가 더해진다
  - 구현부 포인터가 동적 할당된 구현부 객체를 가리키도록 구현부 포인터의 초기화가 이러안야 함 -> 동적 메모리 할당에 따른 오버헤드, bad_alloc(메모리 고갈) 예외 발생 가능성이 높다
  - 인라인 함수의 도움을 제대로 끌어내기 힘들다
- 인터페이스 클래스 : 특수 형태의 추상 기본 클래스로 만듦. 이 기본 클래스로부터 파생 클래스를 만들 수 있게 한다. 파생이 목적이기 때문에 하나의 가상 소멸자와 인터페이스를 구성하는 순수 가상 함수만 들어 있다
  - 팩토리 함수 or 가상 생성자 : 파생 클래스의 생성자 역할을 대신하는 함수를 만들어 놓고 호출함으로써 객체를 생성하는 것
  - 호출되는 함수가 전부 가상함수이기 때문에 가상 테이블 점프에 따르는 비용이 소모된다
  - 가상 테이블 포인터도 객체 하나를 저장하는 데 필요한 메모리 크기를 늘리는 요인이 됨
  - 인라인 함수의 도움을 제대로 끌어내기 힘들다

<br>

