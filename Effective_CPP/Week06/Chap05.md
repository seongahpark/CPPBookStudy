# Chapter 05. 구현

## Item 26. 변수 정의는 늦출 수 있는 데까지 늦추는 근성을 발휘하자
- 변수 정의는 늦출 수 있을 때까지 늦춥시다. 프로그램이 더 깔끔해지며 효율도 좋아집니다.

## Item 27. 캐스팅은 절약, 또 절약! 잊지 말자
```
- const_cast: 객체의 상수성을 없애는 용도
- dynamic_cast: 주어진 객체가 어떤 클래스 상속 계통에 속한 특정 타입인지 아닌지를 결정하는 작업에 쓰입니다.
- reinterpret_cast: 포인터를 int로 바꾸는 등의 하부 수준 캐스팅을 위해 만들어진 연산자
- static_cast: 암시적 변환을 강제로 진행할 때 사용합니다.
```
- C++ 스타일의 캐스팅을 사용하면, 컴파일 할 때, 에러를 잡을 수 있습니다.
- 지금 dynamic_cast를 회피하는 방법이 두개 <br/>
    - 타입 안정성을 갖춘 컨테이너 사용(처음부터 Derived*를 넣는 방법)
    - 가상 함수를 기본 클래스쪽으로 올려두는 방법

## Item 28. 내부에서 사용하는 객체에 대한 핸들을 반환하는 코드는 되도록 피하자
- 어떤 객체의 내부요소에 대한 핸들을 반환하는 것은 되도록 피하세요.

## Item 29: 예외 안정성이 확보되는 그날 위해 싸우고 또 싸우자
- 예외 안전성을 갖춘 함수는 아래의 세 가지 보장 중 하나를 제공
  - 기본적인 보장: 함수 동작 중에 예외가 발생하면, 실행 중인 프로그램에 관련된 모든 것들을 유효한 상태로 유지
  - 강력한 보장: 함수 동작 중에 예외가 발생하면, 프로그램의 상태를 절대로 변경하지 않겠다는 보장
  - 예외불가 보장: 예외를 절대로 던지지 않겠다는 보장
- 실용성이 가장 높은 것은 '강력한 보장'
- 예외안정성이 가장 높은 것은 '예외 불가 보장'(하지만 현실적으로 구현이 어려움)
- 둘 다 안되면 '기본적인 보장'이라도 제공하는 것이 좋다.