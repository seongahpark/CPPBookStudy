# Week 4 - 자원 관리

> Effective C++ / Chap3 / 항목13 - 항목17 (p.118-138)

### 목차

항목 13 : 자원 관리에는 객체가 그만!

항목 14 : 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자

항목 15 : 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자

항목 16 : new 및 delete를 사용할 때는 형태를 반드시 맞추자

항목 17 : new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들자

---

<br>

## 항목 13 : 자원 관리에는 객체가 그만!

> 자원 누출을 막기 위해, 생성자 안에서 자원을 획득하고 소멸자에서 그것을 해제하는 RAII 객체를 사용하자
>

- 자원 (resource) : 사용을 마치고 난 후 시스템에 돌려주어야 하는 모든 것



#### 동적 할당된 자원이 항상 해제되도록 만들기 위한 방법

- 자원 획득시 자원 관리 객체에 넣고 그 자원 해제를 소멸자가 맡도록 함 -> 자원 획득 즉 초기화 (Resource Acquisition Is Initialization)
- 소멸자는 호출 함수를 떠날 때 호출되도록 함
- 자원을 객체에 넣으면 C++이 자동으로 소멸자를 호출해줘 자원 해제가 가능하다



**auto_ptr**

- 스마트 포인터, 표준 라이브러리에 있음
- 가리키고 있는 대상에 대해 소멸자가 자동으로 delete 불러주도록 설계
- 자신이 가리키고 있는 대상에 대해 자동으로 delete 되기 때문에 객체를 가리키는 auto_ptr 개수가 둘 이상이면 안됨 -> 자원이 두 번 삭제되는 결과 = 미정의 동작
- auto_ptr 객체 복사시 원본 객체는 null로 만듦

```c++
void f(){
	std::auto_ptr<Investment> pInv(createInvestment());
	// 팩토리 함수처럼 호출, auto_ptr의 소멸자로 pInv 삭제됨
    std::auto_ptr<Investment> pInv2(pInv1);
    // 이 때, pInv1은 null이 됨
}
```



**참조 카운팅 방식 스마트 포인터 (reference-counting smart pointer)**

- auto_ptr의 대안
- 어떤 자원을 가리키는 외부 객체의 개수
- 개수가 0이되면 해당 자원을 자동으로 삭제
- 참조 상태가 고리를 이루면 없앨 수 없다 (ex. 두 객체가 서로를 가리킴)
- 대표적인 RCSP : tr1::shared_ptr



**부스트**

- 배열에 쓸 수 있는 auto_ptr, shared_ptr
- 항목 55에서 자세히 볼 것

<br>

## 항목 14 : 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자

> 컴파일러에 의해 생성된 객체 복사 함수가 마음에 들지 않을 때 고려해볼 점들

**객체 복사 함수를 직접 구현할 때 고려해야 할 점**

1. 복사를 금지함

   > 복사 함수를 private 멤버로 만듦

2. 관리하고 있는 자원에 대한 참조 카운팅 수행

   > shared_ptr에서 사용하는 방식
   >
   > 참조 카운트가 0이 되면, 삭제자를 매개변수를 통해 지정함

3. 관리하고 있는 자원을 복사

   > 깊은 복사 수행
   >
   > 사본은 포인터 및 그 포인터가 가리키는 새로운 힙 메모리를 가리킴

4. 관리하고 있는 자원의 소유권을 옮김

   > auto_ptr의 복사 동장

<br>

## 항목 15 : 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자

> 실제 자원을 직접 접근해야 하는 RAII 클래스를 만들 때 고려해볼 점

1. 명시적 형변환 (explicit conversion)
   - get 멤버 함수로 실제 포인터의 사본을 얻을 수 있음
   - 원하지 않은 타입 변환이 일어날 여지를 줄여줆
2. 암시적 형변환 (implicit conversion)
   - 암시적 변환 함수를 제공하도록 함
   - 자연스러움이 장점



**shared_ptr과 캡슐화**

- 참조 카운팅 매커니즘에 필요한 장치들은 모두 캡슐화

- 자신이 관리하는 포인터를 쉽게 접근할 수 있는 통로도 제공
- 고객 차원에서 접근해야 할 데이터는 반드시 열어져있어야 하므로 엄격한 캡슐화에 연연하지 말자

<br>

## 항목 16 : new 및 delete를 사용할 때는 형태를 반드시 맞추자

> delete 연산자가 적용되는 객체 = 소멸자가 호출되는 횟수

- new 표현식에 []를 사용했으면 대응되는 delete 표현식에도 반드시 []가 들어가야 함
- 그렇지 않으면 할당한 모든 배열이 소멸되지 않아 미정의 동작으로 빠짐

<br>

## 항목 17 : new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들자

> 자원이 자원 관리 객체로 넘어갈 때 예외가 발생할 경우를 대비

컴파일러에 따라 매개변수의 인자를 넘기는 순서가 달라진다

```c++
processWidget(std::tr1::shared_ptr<Widget>(new Widget), priority());
```

이 예시에 매개변수에 대한 연산은 세 가지가 존재한다.

1. new Widget 실행
2. tr1::shared_ptr 생성자 호출
3. priority 호출

이 때, 1번->3번->2번 순으로 올 때, priority 호출 과정에서 예외가 발생하면  shared_ptr로 막으려고 했던 new Widget 포인터가 유실될 문제가 먼저 발생함



**해결 방법 : 스마트 포인터에 저장하는 코드를 별도의 문장으로 만들어 먼저 실행**

```c++
std::tr1::shared_ptr<Widget> pw(new Widget);
processWidget(pw, priority()); // shared_ptr로 유실될 문제 방지
```



