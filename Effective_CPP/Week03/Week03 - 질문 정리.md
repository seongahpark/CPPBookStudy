# Week 3 - 질문 정리

#### 성아

1. 객체 생성 과정 중에서 가상 함수를 호출하면 안되는 이유를 설명해보시오

   > 생성자 안에서 가상 함수를 호출해도 지금 실행중인 생성자에 해당되는 클래스의 파생 클래스로 내려가지 않기 때문이다

2. C++ 대입 연산자의 특징을 말해보시오

   > 2. 우측 연관 (우측에서부터 처리)
   > 2. 좌변 객체의 참조자를 반환하도록 해야 한다
   
3. 예외 안전성과 자기대입 안전성을 동시에 가진 자기대입 연산자를 구현하는 방법에는 무엇이 있는지 설명해보시오

   > 1. 원본 객체와 복사대상 객체의 주소 비교
   > 2. 문장의 순서를 적절히 조정
   > 3. 복사 후 맞바꾸기 이용

<br>

#### 현준

1. 해당 코드에서 문제점은 무엇인가?

   ![pic1](D:\GITHUB\CPPBookStudy\Effective_CPP\Week03\pic1.png)
   
   >순수 가상 함수인 logTransaction()을 Transaction 클래스의 생성자에서 호출하고 있다.
   >
   >logTransaction을 정의하지 않았다. 설령 하위 클래스에서 구현을 했다고 하더라도 상위 클래스의 생성자에서 가상 함수는 하위 클래스에서의 구현 내용을 알 수 없다. (내려오지 않기 때문)
   
2. 비슷한 구조를 가진 복사 생성자와 복사 대입 연산자가 있을 때, 코드 중복을 줄이고자 복사 생성자에서 복사 대입 연산자를 호출할 때 문제점은?

   > 1. 복사 대입 연산자에서 복사 생성자 호출 : 이미 만들어진 객체를 생성하는 상황. 태어난 아이에게 엄마 뱃속으로 들어가라 하는 것과 같은 상황.
   > 2. 복사 생성자에게 복사 대입 연산자 호출 : 생성 중인 객체는 아직 초기화가 진행되지 않은 상황. 대입 연산자는 초기화가 끝난 객체에 값을 주는 역할이다. 따라서 초기화가 되지도 않은 객체에 값을 주는 말도 안되는 상황 생김. (미정의 동작)

3. 중복 참조 문제와 예외 안전성과 관련된 코드이다. 두 코드의 차이점을 설명하시오

   ![pic2](D:\GITHUB\CPPBookStudy\Effective_CPP\Week03\pic2.png)

   ![pic3](D:\GITHUB\CPPBookStudy\Effective_CPP\Week03\pic3.png)
   
   > - 우측은 pb를 가리키는 *pOrig를 만들고 pOrig를 마지막에 삭제함으로써 예외 안전성 해결
   >- 우측은 원본을 복사해놓고 마지막에 그 메모리를 해제해주기 때문에 메모리 누수와 중복 참조 문제 해결

<br>

#### 재현

1. 객체 생성 과정 중에서 가상 함수를 호출하면 안되는 이유를 설명해보시오

2. 예외 안전성과 자기대입 안전성을 동시에 가진 자기대입 연산자를 구현하는 방법에는 무엇이 있는지 설명해보시오

3. 객체 복사 함수 작성시 확인 사항을 설명해보시오

   > - 해당 클래스 데이터를 모두 복사해야 함
   > - 클래스가 상속한 기본 클래스의 복사함수도 호출
   > - 두 개의 복사함수를 구현시 하나를 이용해 다른 하나를 구현하지 말고, 공통된 동작을 제 3의 함수에다 분리해서 호출