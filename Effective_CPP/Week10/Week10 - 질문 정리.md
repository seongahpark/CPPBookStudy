# Week 10 - 질문 정리

#### 성아

1. [항목 46] 스마트 포인터에서 암시적 변환이 가능하도록 하게 만드는 방법은?

   > 호환되는 모든 타입을 받아들이는 멤버 함수를 만들려면 멤버 함수 템플릿을 사용하자
   
2. [항목 47] STL 반복자의 종류에 대해 아는 대로 설명해보시오 

   > 입력 반복자 : 전진만 가능, 한 번에 한 칸씩만 이동, 현재 위치에서 읽기만 가능
   >
   > 출력 반복자 : 입력 반복자와 특성이 동일한데, 쓰기만 가능하다는게 다름
   > 
   > 순방향 반복자 : 입출력 반복자가 하는 일 + 현재 위치에서 읽기와 쓰기 동시에 가능, 여러 번 사용 가능
   > 
   > 양방향 반복자 : 순방향 반복자 + 뒤로가기 기능
   >
   > 임의 접근 반복자 : 양방향 반복자 + 반복자 산술 연산
   
3. [항목 48] 템플릿 메타프로그래밍의 개념과 장단점에 대해 설명해보시오

   > TMP는 컴파일 도중에 실행되는 템플릿 기반의 프로그램을 작성하는 일
   >
   > 장점은 실행코드가 작아지고, 실행 시간이 짧아지며, 메모리를 적게 먹는다
   >
   > 단점은 컴파일 시간이 길어진다


<br>

#### 재현

1. [항목 48] 템플릿 메타프로그래밍의 장점은?

   > 다른 방법으로는 까다롭거나 불가능한 일을 쉽게할 수 있다
   >
   > 컴파일이 진행되는 동안 실행돼, 기존 작업을 런타임 영역에서 컴파일 타임 영역으로 전환 가능하다

2. [항목 48] 템플릿 메타 프로그래밍에서는 어떻게 루프 효과를 내는가?

   > 재귀식 템플릿 인스턴스화

3. [항목 46] 모든 매개변수에 대해 암시적 타입 변환을 지원하는 템플릿과 관계가 있는 함수를 제공하는 클래스 템플릿을 만들려고 한다면, 어떻게 정의해야 하는가?

   > 클래스 템플릿 안에 프렌드 함수로 정의해야 한다

<br>

#### 현준

1. [항목 47] 템플릿 메타 프로그래밍에서 `if ... else` 문을 구사하기 위한 방법은 무엇인가?

   > 함수 오버로딩 기법을 사용한다
   >
   > 타입별로 오버로딩된 함수들을 랩핑한 함수를 만들면 해결된다
   >
   > if ... else는 런타임에 동작하지만, 오버로딩은 컴파일 타임에 동작하는 특성을 활용한 방법이다


2. [항목 45] 일반화 복사생성자(generalized copy constructor)를 만들었을 때 복사 생성자가 컴파일러에 의해 자동생성 되는가?

   > 만약 호출되어야 한다면 자동생성이 된다
   >
   > 복사 생성자가 필요한데 프로그래머가 직접 선언하지 않으면 컴파일러가 자동으로 만든다
   >
   > 일반화 복사 생성자(멤버 템플릿)을 선언하는 행위는 컴파일러가 복사 생성자(비템플릿)을 만드는 것을 막는 요소가 아니다


3. [항목 47] vector는 임의 접근 반복자를 사용하고 list는 양방향 반복자를 사용하는데, 임의 접근 반복자는 +=, -= 연산자를 지원하는 반면, 양방향 반복자는 지원하지 않는 이유는?

   > Vector 자료구조는 메모리 구조가 연속적이다. 따라서 +=, -= 연산이 상수 시간 안에 가능하다
   >
   > List 자료구조는 노드 간의 메모리 구조가 비연속적이다. 따라서 +=, -= 연산이 상수 시간에 불가능하다.


