# Week 9 - 템플릿과 일반화 프로그래밍

> Effective C++ / Chap7 / 항목41 - 항목44 (p.296-319)

### 목차

항목 41 : 템플릿 프로그래밍의 천릿길도 암시적 인터페이스와 컴파일 타임 다형성부터

항목 42 : typename의 두 가지 의미를 제대로 파악하자

항목 43 : 템플릿으로 만들어진 기본 클래스 안의 이름에 접근하는 방법을 알아 두자

항목 44 : 매개변수에 독립적인 코드는 템플릿으로부터 분리시키자

---

<br>


## 항목 41 : 템플릿 프로그래밍의 천릿길도 암시적 인터페이스와 컴파일 타임 다형성부터

> 클래스 및 템플릿은 모두 인터페이스와 다형성을 지원한다
>
> 클래스의 경우, 인터페이스는 명시적이며 함수의 시그니처를 중심으로 구성되어 있다
>
> 다형성은 프로그램 실행 중에 가상 함수를 통해 나타난다
>
> 템플릿 매개변수의 경우, 인터페이스는 암시적이며 유효 표현식에 기반을 두어 구성된다
>
> 다형성은 컴파일 중에 템플릿 인스턴스화와 함수 오버로딩 모호성 해결을 통해 나타난다

- **명시적 인터페이스(explicit interface)** : 소스 코드에 명시적으로 드러나는 인터페이스. 컴파일 도중에 점검됨
- **암시적 인터페이스(implicit interface)** : 템플릿이 제대로 컴파일 되기 위해 유효한 표현식을 지원하는 인터페이스. 컴파일 도중에 점검됨
  - 템플릿 안에서 객체를 사용할 때, 템플릿에서 요구하는 암시적 인터페이스를 객체가 지원하지 않으면 사용이 불가능하다
- **런타임 다형성(runtime polymorphism)** : 특정한 클래스에 대한 실제 호출이 객체의 동적 타입을 기반으로 런타임에 결정되는 현상
- **컴파일 타임 다형성(complie-time polymorphism)** : 템플릿의 인스턴스화는 컴파일 도중에 일어나고, 인스턴스화에서 어떤 템플릿 매개변수가 들어가냐에 따라 호출되는 함수가 달라지는 현상


<br>

## 항목 42 : typename의 두 가지 의미를 제대로 파악하자

> 템플릿 매개변수를 선언할 때, class 및 typename은 서로 바꾸어 사용해도 무방
>
> 중첩 의존 타입 이름을 식별하는 용도에는 반드시 typename 사용
>
> 단, 중첩 의존 이름이 기본 클래스 리스트에 있거나 멤버 초기화 리스트 내의 기본 클래스 식별자로 있는 경우 예외

- 템플릿 매개변수를 선언할 때는 `class`와 `typename`의 뜻이 같다
- **의존 이름(dependent name)** : 템플릿 내의 템플릿 매개변수에 종속된 이름
- **중첩 의존 이름(nested dependent name)** : 의존 이름이 어떤 클래스 안에 중첩되어 있는 경우
- **비의존 이름(non-dependent name)** : 템플릿 매개변수가 어떻든 상관없는 타입 이름

#### typename
- `typename` 키워드는 중첩 의존 이름만 식별하는 데 사용해야 한다
  ```cpp
  template<typename C> // typename 사용 가능 (= class)
  void f(const C& container, // typename 사용하면 안됨
         typename C::iterator iter); // typename 꼭 사용해야 함
  ```
- 단, 예외가 있다. 아래 해당 사항에서는 typename 사용 불가
  1. 중첩 의존 타입 이름이 기본 클래스의 리스트에 있는 경우
  2. 중첩 의존 타입 이름이 멤버 초기화 리스트 내의 기본 클래스 식별자로 있을 경우

<br>

## 항목  43 : 템플릿으로 만들어진 기본 클래스 안의 이름에 접근하는 방법을 알아 두자

> 파생 클래스 템플릿에서 기본 클래스 템플릿의 이름을 참조할 때는, "this->"를 접두사로 붙이거나 기본 클래스 한정문을 명시적으로 써주는 것으로 해결한다

- 컴파일러가 클래스 템플릿의 정의와 마주칠 때, 이 클래스가 어디서 파생된 것인지 알 수 없다
- `template<>` : 이건 템플릿도 아니고 클래스도 아니다
- **완전 템플릿 특수화(total template specialization)** : 템플릿의 매개변수들이 빠짐없이(완전히) 구체적인 타입으로 정해진 상태

#### 파생 클래스 템플릿에서 기본 클래스 템플릿의 이름 참조 방법

1. 기본 클래스 함수에 대한 호출문 앞에 `this->` 붙이기
```cpp
template<typename Company>
class LoggingMsgSender: public MsgSender<Company> {
pulbic:
  ...
  void sencClearMsg(const MsgInfo& info){
    "메세지 전송 전" 정보를 로그에 기록함;
    this->sendClear(info); // sendClear가 상속되는 것으로 가정됨
    "메세지 전송 후" 정보를 로그에 기록함;
  }
}
```

2. `using` 선언 사용
```cpp
template<typename Company>
class LoggingMsgSender: public MsgSender<Company> {
pulbic:
  using MsgSender<Company>::sendClear; // 컴파일러에게 sendClear가 기본클래스에 있다 가정하라고 알려줌
  ...
  void sencClearMsg(const MsgInfo& info){
    "메세지 전송 전" 정보를 로그에 기록함;
    this->sendClear(info); // sendClear가 상속되는 것으로 가정됨
    "메세지 전송 후" 정보를 로그에 기록함;
  }
}
```

3. 호출할 함수가 기본 클래스의 함수라는 점을 명시적으로 지정 (비추)
- 한계점 : 호출되는 함수가 **가상 함수**인 경우에 명시적 한정을 해버리면 가상 함수 바인딩이 무시됨
```cpp
template<typename Company>
class LoggingMsgSender: public MsgSender<Company> {
pulbic:
  ...
  void sencClearMsg(const MsgInfo& info){
    "메세지 전송 전" 정보를 로그에 기록함;
    MsgSender<Company>::sendClear(info); // sendClear가 상속되는 것으로 가정됨
    "메세지 전송 후" 정보를 로그에 기록함;
  }
}
```

#### C++의 이른 진단

컴파일러가 기본 클래스의 멤버에 대한 참조가 무효한지를 진단하는 과정

1. (미리) 파생 클래스 템플릿의 정의가 구문분석 되는 시기
2. (나중) 파생 클래스 템플릿이 특정한 템플릿 매개변수를 받아 인스턴스화 될 때 발생

C++은 1번, **이른 진단(early diagnose)**을 선호한다

즉, 파생 클래스가 템플릿으로부터 인스턴스화 될 때 컴파일러가 기본 클래스의 내용에 대해 모른다고 가정하는 이유가 여기서 나옴


<br>

## 항목 44 : 매개변수에 독립적인 코드는 템플릿으로부터 분리시키자

> 템플릿 사용시 비슷한 클래스와 함수가 여러 개 만들어진다. 템플릿 매개변수에 종속되지 않은 템플릿 코드는 비대화의 원인
>
> 비타입 템플릿 매개변수로 생기는 코드 비대화의 경우, 템플릿 매개변수를 함수 매개변수 혹은 클래스 데이터 멤버로 대체하여 해결 가능
>
> 타입 매개변수로 생기는 코드 비대화의 경우, 동일한 이진 표현 구조를 가지고 인스턴스화 되는 타입들이 한 가지 함수 구현을 공유하게 만들어 비대화를 감소

- 템플릿의 장점
  - 코딩 시간 절약, 코드 중복 회피의 두 마리 토끼를 잡아준다

- 템플릿의 단점
  - **코드 비대화(code bloat)** : 같거나 거의 비슷한 내용의 코드와 데이터가 여러 벌로 중복되어 이진 파일로 구워지는 현상

- 코드 비대화 감소 방안
  - **함수로 분할** : **공통성 및 가변성 분석(commonality and variability)**을 통해 공통 부분을 발견하면 별도의 새로운 클래스로 옮겨 클래스를 상속 혹은 객체 합성 한다
  - **메모리 할당 방법의 결정 권한을 파생 클래스로 넘김** : 동적 메모리 할당이 필요 없는 파생 클래스가 되지만, 객체 자체의 크기가 커질 수 있다. 
  - **한 가지 함수 구현을 공유** : 동일한 이진 표현 구조를 가지고, 인스턴스화 되는 타입들이 멤버 함수 집합을 하나만 사용해도 되도록 만든다.
    - C++ STL의 `vector`, `deque`, `list` 등의 템플릿의 구현이 예시에 해당된다

- **비타입 매개변수(non-type parameter)** 
  - 타입이 아닌 값. class, template 키워드 대신 특정 타입을 지정하여 사용한다
  - 비타입 매개변수 템플릿이 인스턴스화 될 때, 매개변수는 사용자가 지정하거나, 컴파일러가 추론한 값으로 대체
  - 정수형과 boolean형만 가능하다
  - 상수만 가능하다


<br>