# Week 1 - 질문 정리

#### 성아

1. C++은 다중 패러다임 프로그래밍 언어인데 C++이 제공하는 언어는 어떤 것들이 있을까?

   > (C언어) + (객체 지향 개념의 C++) + (템플릿 C++) + (STL)

2. #define을 사용할 시 단점

   > 현준 답에 상세히 설명

3. 정적 객체란 무엇인가요?

   > 생성된 시점부터 프로그램이 끝날 때 까지 살아있는 객체

   - 그렇다면 정적 객체를 프로그램 종료 전에 강제로 소멸할 수 있는 방법이 있을까?

<br>

#### 현준

1. 클래스 내의 static으로 선언한 변수는 클래스 내에서는 정의할 수 없다. 그러면 어떡해야 하나?

   >static은 전역에서 정의를 해야 함
   >
   >클래스 내(지역)에서 static 변수를 정의하는 것이 가능하다고 가정한다면 클래스 사용을 위해 선언할 때 마다 static 변수가 정의된다.
   >
   >하지만 static 멤버 변수는 모든 객체가 공유해야 하므로 프로그램 전체 영역에서 메모리 유지가 돼야 함
   >
   >따라서 반드시 전역 범위에서 정의 및 초기화를 해줘야 함

   - 하지만 static const 라면 어떨까?
   - enum hack은?

2. #define과 비교했을 때, const의 이점은 무엇인가?

   > ※ #define은 전처리기 (책에서는 선행 처리자라 표기)
   >
   > #define은 컴파일 시 상수로 치환되며 주소값이 존재하지 X
   >
   > 버그 발생 시 디버깅 시에 #define으로 인한 버그를 찾아내기 힘들다
   >
   > 이에 반해, const는 주소값이 할당되므로 버그를 찾는 것이 용이
   > 
   >
   >
   > 또한,  const를 썼을 경우 컴파일을 거친 최종 코드의 크기가 더 작을 수 있음. 크기가 더 작다보니 컴파일 시간에도 영향을 미침
   >
   > #define은 코드 등장 시기 마다 사본이 복사되어 들어가지만 const는 사본은 한 개만 생긴다.

   - enum의 이점 : type 지정 가능. 메모리에 올라가지 X

3. const_cast<T>와 static_cast<T>에 관해 설명해보시오

   > const_cast<T>(표현식) -> 표현식의 const를 제거, 상수 객체를 비상수 객체로 캐스팅
   >
   > static_cast<T>(표현식) -> 표현식을 T 자료형으로 캐스팅, 상수 객체를 비상수 객체로 캐스팅 하는 것은 불가능


