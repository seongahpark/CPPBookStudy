# Week 1 - C++에 왔으면 C++의 법을 따릅시다

> Effective C++ / Chap1 / 항목1 - 항목4 (p.51-79)

### 목차

항목 1 : C++를 언어들의 연합체로 바라보는 안목은 필수

항목 2 : #define을 쓰려거든 const, enum, inline을 떠올리자

항목 3 : 낌새만 보이면 const를 들이대 보자!

항목 4 : 객체를 사용하기 전에 반드시 그 객체를 초기화하자

---

<br>

## 항목 1 : C++를 언어들의 연합체로 바라보는 안목은 필수

> C++은 **다중패러다임 프로그래밍 언어**
>
> **C++ = 절차적 + 객체 지향 + 함수식 + 일반화 + 메타프로그래밍**
>
> C++을 사용하는 이유 -> **다양한 표현력과 유연성**

#### c++이 제공하는 하위 언어

1. **C** : 블록, 문장, 선생 처리자, 데이터타입, 배열, 포인터 등

2. **객체 지향 개념의 C++** : 클래스, 캡슐화, 상속, 다형성, 가상 함수(동적 바인딩)

3. **템플릿 C++** : 템플릿 메타프로그래밍

   > 템플릿 메타 프로그래밍 : 컴파일 시간에 연산을 수행하는 개념

4. **STL** : 템플릿 라이브러리

<br>

## 항목 2 : #define을 쓰려거든 const, enum, inline을 떠올리자

#### #define

```c++
#define ASPECT_RATIO 1.653
//ASPECT_RATIO -> Symbolic name
```

- 매크로, 정의되면 컴파일이 끝날 때 가지 유효 (#undef 되지 않으면)
- 기호식 이름(symbolic name)이 컴파일러로 가기 전에 선행 처리자가 숫자 상수(1.653)로 바꾸어 버림
- 컴파일 에러시 숫자 상수만 보여 출처를 알기 힘듦
- 해결방법 : const 사용



#### const 상수

- define은 사본이 등장 횟수만큼 생기지만 const는 한 개만 생성

- **상수 포인터 (constant pointer)**

  - 포인터는 반드시 상수로 선언, 포인터가 가리키는 대상도 상수로 선언

    ``` c++
    cosnt char * const authorName = "Scott Meyrs";
    ```

  - 문자열 상수를 사용할 때는 string 객체가 사용하기 더 괜찮다

- **클래스 상수**

  - 상수의 유효범위를 클래스로 한정할 때 사용
  
  - 사본 개수를 하나로 하고싶다면 정적 멤버로 만들어야 함 
  
  - 선언 부분은 헤더파일에 정의 부분은 구현 파일에 둠
  
    ```c++
    class CostEstimate{
    private:
    	static const double FudgeFactor;
        //정적 클래스 상수의 선언
    };
    
    const double CostEstimate::FudgeFactor = 1.35;
    //정적 클래스 상수의 정의
    ```
  
    

#### Enum

- Enum Hack : 컴파일 도중에 클래스 상수 값이 필요할 때 사용

  - 장점 : const 객체에 대한 메모리를 만들지 않고, #define처럼 쓸데없는 메모리 할당 X -> 템플릿 메타프로그래밍 핵심

    ```c++
    class GamePlayer{
    private:
    	enum { Numturns = 5; }
        //배열의 크기를 미리 알아야되기 때문에 사용
    	int scores[Numturns];
    }
    ```

    

#### Inline

- 함수처럼 쓰이는 매크로를 만들 때 사용
- 기존 매크로의 효율을 유지하면서 정규 함수의 모든 동작방식 및 타입 안전성까지 취함

```c++
template<typename T>
inline void callWithMax(const T& a, const T& b){
	f(a > b ? a : b);
}
```

<br>

## 항목 3 : 낌새만 보이면 const를 들이대 보자!

- ```* const``` 인 경우 **포인터 자체가 상수**

- 이 외에는 받아들이는 매개벼수 타입이 모두 같음. const 위치 상관 X

- 반복자를 상수로 선언하는 경우

  - 반복자를 const로 선언 -> 반복자가 가리키는 대상 변경 O, 반복자는 변경 X
  - 변경이 불가능한 객체를 가리키는 반복자 -> 반복자 변경 O, 반복자가 가리키는 대상 변경 X

  ```C++
  const std::vector<int>::iterator iter = vec.begin();
  // T* const 처럼 동작
  // iter가 가리키는 대상 변경 O, 반복자는 변경 X
  std::vector<int>::const_iterator cIter = vec.begin();
  // const T* 처럼 동작
  // iter가 가리키는 대상 변경 X, 반복자는 변경 O
  ```

- 상수성

  - 비트수준 상수성(bitwise constness) : 물리적 상수성이라고도 함. 어떤 멤버 함수가 그 객체의 어떤 데이터 멤버도 건드리지 않아야 멤버 함수를 const임을 인정. C++에서 정의하고 있는 상수성
  - 논리적 상수성(logical constness) : 상수 멤버 함수이지만 일부 몇 비트 정도는 바꿀 수 있되, 사용자측만 알아채지 못하면 상수 멤버 자격을 줌
  - mutable :

- 상수 멤버 및 비상수 멤버 함수가 기능적으로 똑같게 구현돼있을 때는 비상수 버전이 상수 버전을 호출하도록 만들어라

<br>

## 항목 4 : 객체를 사용하기 전에 반드시 그 객체를 초기화하자

> 생성자 규칙 : **대입 (assignment)**을 **초기화(initialization)**와 헷갈리지 않는다

- 객체를 구성하는 데이터의 초기화 순서

  1. 기본 클래스는 파생 클래스보다 먼저 초기화
  2. 클래스 데이터 멤버는 선언된 순서대로 초기화

- 정적 객체(static object)

  - 생성된 시점부터 프로그램이 끝날 때 까지 살아있는 객체

  - ```c++
    - 전역 객체 -> 비지역 정적 객체
    - 네임스페이스 유효범위에서 정의된 객체 -> 비지역 정적 객체
    - 클래스 안에서 static으로 선언된 객체 -> 비지역 정적 객체
    - 함수 안에서 static으로 선언된 객체 -> 지역 정적 객체
    - 파일 유효 범위에서 static으로 정의된 객체 -> 비지역 정적 객체
    ```

  - 

