# Week 2 - 생성자, 소멸자 및 대입 연산자

> Effective C++ / Chap2 / 항목5 - 항목8 (p.81-99)

### 목차

항목 5 : C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자

항목 6 : 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자

항목 7 : 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자

항목 8 : 예외가 소멸자를 떠나지 못하도록 붙들어 놓자

---

<br>

## 항목 5 : C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자

> 컴파일러는 경우에 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있다

1. 복사 생성자
2. 복사 대입 연산자 : 기본 클래스의 복사 대입 연산자가 private으로 선언한 경우, 파생된 클래스는 암시적 복사 대입 연산자를 가질 수 없다.
3. 소멸자 : 기본 클래스의 소멸자가 비가상 소멸자 -> 상속된 소멸자 역시 비가상 소멸자



템플릿 안에 생성자가 선언되어 있으면, 컴파일러는 기본 생성자를 만들어내지 않는다.

선언되지 않은 요소가 있으면 각 함수의 기본형이 컴파일러에 의해 만들어짐.

컴파일러의 동작 원리 : Legal + Resonable

<br>

## 항목 6 : 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자

컴파일러가 생성하는 함수는 public 멤버가 됨

만약 복사 생성자 및 복사 대입 연산자를 private 멤버로 선언한다면 -> 컴파일러가 생성하는 것을 막을 수 있음. 외부로부터의 호출 차단

하지만 이 방법은 friend 함수가 호출 할 수 있는 것이 허점

정의를 하지 말아라 -> 정의되지 않은 함수는 호출되지 않는다.

클래스의 복사 방지책 : 선언만 하고 정의하지 말 것

> 컴파일러에서 자동으로 제공하는 기능을 막으려면, 해당 멤버 함수를 private으로 선언한 후, 구현은 하지 않아야 함

<br>

## 항목 7 : 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자

- 팩토리 함수 : 새로 생성된 파생 클래스 객체에 대한 기본 클래스 포인터를 반환하는 함수. 자원 누출을 막기위해 해제(delete)가 필수
- 기본 클래스 포인터를 통해 삭제될 때의 문제점 : 부분 소멸의 문제. 함수에서 포인터를 통해 날아오는 객체는 소멸되지 않고, 소멸자도 실행되지 않음
- 해결방법 : 기본 클래스 소멸자 앞에 virtual을 붙인다 -> 객체, 파생 클래스 모두 소멸
- 가상 함수 테이블 포인터 (vptr) : 가상 함수의 주소들의 배열 
- 가상 함수 테이블 (vtbl) : 가상 함수 테이블 포인터의 배열
- 가상함수를 하나라도 갖고 있다 -> vtbl을 반드시 갖고 있다.
- std::string, vector, list, set 등은 가상 소멸자가 없다
- 추상 클래스 : 
- 기본 클래스에 가상 소멸자를 주는 조건 : 다형성을 가진 기본클래스 일 때만 가능
- 다형성 : 

<br>

## 항목 8 : 예외가 소멸자를 떠나지 못하도록 붙들어 놓자

- 소멸자에서 예외가 발생하는 경우
  1. 프로그램을 바로 끝냄 : abort 호출.
  2. 예외를 삼킴 : 예외를 무시한 뒤라도 프로그램이 신뢰성 있게 실행할 수 있어야 함
- 예외에 대해 사용자가 반응해야 하는 경우 : 해당 연산을 제공하는 함수는 반드시 보통의 함수여야만 함 (소멸자 X)