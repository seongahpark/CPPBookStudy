# Week 2 - 질문 정리

#### 성아

1. 컴파일러에서 자동으로 복사 연산자를 수행하지 못하도록 막으려고 하면 어떻게 해야되는지 설명해보시오

   > 해당 복사 연산자 함수를 private으로 만든 후 선언만 진행해야 함

2. virtual 함수가 필요한 이유를 설명해 보시오

   > virtual function : 파생 클래스에서 재정의할 것으로 기대하는 멤버 함수를 의미 -> 호출하는 객체의 동적 타입에 따라 실제 호출할 함수가 결정됨
   > 
   >
   > 바인딩 : 함수를 호출할 시 어느 블록에 있는 함수를 실행하라
   > 정적 바인딩 : 컴파일 타임에 고정된 메모리 주소로 변환
   >
   > 동적 바인딩 : 런타임에 객체를 결정하여 올바른 함수가 실행되도록 함
   >
   > 1. 기초 클래스 타입의 포인터나 참조를 통해 호출될 때 동적 바인딩이 필요한데 이때를 위해 virtual function을 사용
   > 2. (책 내용) 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언해야 함

3. 소멸자에서 예외가 발생하는 경우에는 어떤 대응 방법이 있는가

   > 1. 프로그램을 바로 끝냄. abort 호출
>
   >    ※ abort() : 프로그램 비정상적으로 종료 (stdlib.h)
   >
   > 2. 예외를 삼킴. 단, 예외를 무시하고도 프로그램이 신뢰성 있게 실행할 수 있어야 함
   
   - 소멸자는 인터페이스 개념
   - 실제로 현업에서도 clean up 함수같은걸 만들어 소멸자 내부에서 호출하는 형태로 객체가 쓰는 heap 영역 메모리를 다 정리하도록 만든다고 함 (feat. 개존멋 능력자 재현님)

<br>

#### 현준

1. 클래스 안에 사용자 정의 생성자를 작성했을 때 기본 생성자가 생성될까요?

   >아니요. 사용자가 직접 생성자를 정의하면 컴파일러는 생성자를 자동적으로 생성하지 않습니다.
   
   1.1 그렇다면 생성자가 정의되어 있지 않을 때는?
   
   > 기본 생성자만 컴파일러에 의해 생성된다.
   
2. 복사가 불가능한 유일한 문서(객체)를 만들고자 할 때 어떻게?

   > 성아 답 참고
   
3.  A 클래스와 A를 상속받는 B 클래스가 있을 때 소멸자의 호출 순서

   > - B 소멸자 호출 -> A 소멸자 호출
   >- 파생 클래스 -> 상위 클래스 순으로 호출된다.

<br>

#### 재현

1. 컴파일러의 자동 생성자 함수를 방지하는 방법은?

   > 생성자를 '선언'만 Private에 하도록한다.

2. 32Bit와 64Bit 차이

   > 레지스터의 크기 또는 CPU가 처리하는 데이터의 최소 단위

3. 팩토리 메소드는 무엇인가?

   > 객체를 생성하기 위한 인터페이스를 정의하고, 어떤 클래스의 인스턴스를 생성할지에 대한 처리는 서브클래스가 결정하는 디자인 패턴